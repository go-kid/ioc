<!DOCTYPE html>
<html lang="en" style="height: 100%">
<head>
    <meta charset="UTF-8"/>
    <title>Tutorial Demo</title>
</head>
<body style="height: 100%">
<!--/* 图的画布容器 */-->
<div style="height: 100%" id="container"></div>

<!--/* 引入 G6 */-->
<script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"></script>

<script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script>


<script>
    const {
        Util,
        registerBehavior,
        registerEdge,
        registerNode
    } = G6;

    function render(rawData) {
        const isInBBox = (point, bbox) => {
            const {
                x,
                y
            } = point;
            const {
                minX,
                minY,
                maxX,
                maxY
            } = bbox;

            return x < maxX && x > minX && y > minY && y < maxY;
        };

        const itemHeight = 20;
        registerBehavior("dice-er-scroll", {
            getDefaultCfg() {
                return {
                    multiple: true,
                };
            },
            getEvents() {
                return {
                    itemHeight,
                    wheel: "scorll",
                    click: "click",
                    "node:mousemove": "move",
                    "node:mousedown": "mousedown",
                    "node:mouseup": "mouseup"
                };
            },
            scorll(e) {
                e.preventDefault();
                const {
                    graph
                } = this;
                const nodes = graph.getNodes().filter((n) => {
                    const bbox = n.getBBox();

                    return isInBBox(graph.getPointByClient(e.clientX, e.clientY), bbox);
                });

                const x = e.deltaX || e.movementX;
                let y = e.deltaY || e.movementY;
                if (!y && navigator.userAgent.indexOf('Firefox') > -1) y = (-e.wheelDelta * 125) / 3

                if (nodes) {
                    const edgesToUpdate = new Set();
                    nodes.forEach((node) => {
                        const model = node.getModel();
                        if (model.attrs.length < 2) {
                            return;
                        }
                        const idx = model.startIndex || 0;
                        let startX = model.startX || 0.5;
                        let startIndex = idx + y * 0.02;
                        startX -= x;
                        if (startIndex < 0) {
                            startIndex = 0;
                        }
                        if (startX > 0) {
                            startX = 0;
                        }
                        if (startIndex > model.attrs.length - 1) {
                            startIndex = model.attrs.length - 1;
                        }
                        graph.updateItem(node, {
                            startIndex,
                            startX,
                        });
                        node.getEdges().forEach(edge => edgesToUpdate.add(edge))
                    });
                    // G6 update the related edges when graph.updateItem with a node according to the new properties
                    // here you need to update the related edges manualy since the new properties { startIndex, startX } for the nodes are custom, and cannot be recognized by G6
                    edgesToUpdate.forEach(edge => edge.refresh())
                }


            },
            click(e) {
                const {
                    graph
                } = this;
                const item = e.item;
                const shape = e.shape;
                if (!item) {
                    return;
                }

                if (shape.get("name") === "collapse") {
                    graph.updateItem(item, {
                        collapsed: true,
                        size: [300, 50],
                    });
                    setTimeout(() => graph.layout(), 100);
                } else if (shape.get("name") === "expand") {
                    graph.updateItem(item, {
                        collapsed: false,
                        size: [300, 80],
                    });
                    setTimeout(() => graph.layout(), 100);
                }
            },
            mousedown(e) {
                this.isMousedown = true;
            },
            mouseup(e) {
                this.isMousedown = false;
            },
            move(e) {
                if (this.isMousedown) return;
                const name = e.shape.get("name");
                const item = e.item;

                if (name && name.startsWith("item")) {
                    this.graph.updateItem(item, {
                        selectedIndex: Number(name.split("-")[1]),
                    });
                } else {
                    this.graph.updateItem(item, {
                        selectedIndex: NaN,
                    });
                }
            },
        });

        registerEdge("dice-er-edge", {
            draw(cfg, group) {
                const edge = group.cfg.item;
                const sourceNode = edge.getSource().getModel();
                const targetNode = edge.getTarget().getModel();

                const sourceIndex = sourceNode.attrs.findIndex(
                    (e) => e.key === cfg.sourceKey
                );

                const sourceStartIndex = sourceNode.startIndex || 0;

                let sourceY = 15;

                if (!sourceNode.collapsed && sourceIndex > sourceStartIndex - 1) {
                    sourceY = 30 + (sourceIndex - sourceStartIndex + 0.5) * itemHeight;
                    sourceY = Math.min(sourceY, 80);
                }

                const targetIndex = targetNode.attrs.findIndex(
                    (e) => e.key === cfg.targetKey
                );

                const targetStartIndex = targetNode.startIndex || 0;

                let targetY = 15;

                if (!targetNode.collapsed && targetIndex > targetStartIndex - 1) {
                    targetY = (targetIndex - targetStartIndex + 0.5) * itemHeight + 30;
                    targetY = Math.min(targetY, 80);
                }

                const startPoint = {
                    ...cfg.startPoint
                };
                const endPoint = {
                    ...cfg.endPoint
                };

                startPoint.y = startPoint.y + sourceY;
                endPoint.y = endPoint.y + targetY;

                let shape;
                if (sourceNode.id !== targetNode.id) {
                    shape = group.addShape("path", {
                        attrs: {
                            stroke: "#5B8FF9",
                            path: [
                                ["M", startPoint.x, startPoint.y],
                                [
                                    "C",
                                    endPoint.x / 3 + (2 / 3) * startPoint.x,
                                    startPoint.y,
                                    endPoint.x / 3 + (2 / 3) * startPoint.x,
                                    endPoint.y,
                                    endPoint.x,
                                    endPoint.y,
                                ],
                            ],
                            endArrow: true,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: "path-shape",
                    });
                } else if (!sourceNode.collapsed) {
                    let gap = Math.abs((startPoint.y - endPoint.y) / 3);
                    if (startPoint["index"] === 1) {
                        gap = -gap;
                    }
                    shape = group.addShape("path", {
                        attrs: {
                            stroke: "#5B8FF9",
                            path: [
                                ["M", startPoint.x, startPoint.y],
                                [
                                    "C",
                                    startPoint.x - gap,
                                    startPoint.y,
                                    startPoint.x - gap,
                                    endPoint.y,
                                    startPoint.x,
                                    endPoint.y,
                                ],
                            ],
                            endArrow: true,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                        name: "path-shape",
                    });
                }

                return shape;
            },
            afterDraw(cfg, group) {
                const labelCfg = cfg.labelCfg || {};
                const edge = group.cfg.item;
                const sourceNode = edge.getSource().getModel();
                const targetNode = edge.getTarget().getModel();
                if (sourceNode.collapsed && targetNode.collapsed) {
                    return;
                }
                const path = group.find(
                    (element) => element.get("name") === "path-shape"
                );

                const labelStyle = Util.getLabelPosition(path, 0.5, 0, 0, true);
                const label = group.addShape("text", {
                    attrs: {
                        ...labelStyle,
                        text: cfg.label || '',
                        fill: "#000",
                        textAlign: "center",
                        stroke: "#fff",
                        lineWidth: 1,
                    },
                });
                label.rotateAtStart(labelStyle.rotate);
            },
        });


        registerNode("dice-er-box", {
            draw(cfg, group) {
                console.log(cfg)
                const collapseBarHeight = 15
                const itemCount = cfg.attrs.length + 1;
                const expandY = Math.max(itemCount * itemHeight, 80)
                const titleHeight = 30
                const width = 250;
                const height = Math.max(itemHeight * cfg.attrs.length, expandY + collapseBarHeight + 1);


                const boxStyle = {
                    radius: 4,
                };

                const {
                    attrs = [],
                    startIndex = 0,
                    selectedIndex,
                    collapsed,
                    icon,
                    nodeType,
                } = cfg;

                const colorSchema = {
                    abstract: "#d95209",
                    class: "#096DD9",
                    struct: "#389b07",
                    interface: "#6709d9",
                }
                boxStyle.stroke = colorSchema[nodeType] || "#096DD9"

                const list = attrs;
                const afterList = list.slice(
                    Math.floor(startIndex),
                    Math.floor(startIndex + itemCount - 1)
                );
                const offsetY = (0.5 - (startIndex % 1)) * itemHeight + titleHeight;

                //title
                group.addShape("rect", {
                    attrs: {
                        fill: boxStyle.stroke,
                        height: titleHeight,
                        width,
                        radius: [boxStyle.radius, boxStyle.radius, 0, 0],
                    },
                    draggable: true,
                });

                let fontLeft = 12;

                if (icon && icon.show !== false) {
                    group.addShape("image", {
                        attrs: {
                            x: 8,
                            y: 8,
                            height: 16,
                            width: 16,
                            ...icon,
                        },
                    });
                    fontLeft += 18;
                }

                group.addShape("text", {
                    attrs: {
                        y: 22,
                        x: fontLeft,
                        fill: "#fff",
                        text: cfg.label,
                        fontSize: 12,
                        fontWeight: 500,
                    },
                });

                function collapseBarY() {
                    return collapsed ? titleHeight : Math.max(expandY, 80)
                }

                //gray collapse bar
                group.addShape("rect", {
                    attrs: {
                        x: 0,
                        y: collapseBarY(),
                        height: collapseBarHeight,
                        width,
                        fill: "#eee",
                        radius: [0, 0, boxStyle.radius, boxStyle.radius],
                        cursor: "pointer",
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: collapsed ? "expand" : "collapse",
                });

                //gray collapse bar icon
                group.addShape("text", {
                    attrs: {
                        x: width / 2 - 6,
                        y: (collapseBarY()) + 12,
                        text: collapsed ? "+" : "-",
                        width,
                        fill: "#000",
                        radius: [0, 0, boxStyle.radius, boxStyle.radius],
                        cursor: "pointer",
                    },
                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                    name: collapsed ? "expand" : "collapse",
                });

                const keyshape = group.addShape("rect", {
                    attrs: {
                        x: 0,
                        y: 0,
                        width,
                        height: collapsed ? 45 : height,
                        ...boxStyle,
                    },
                    draggable: true,
                });

                if (collapsed) {
                    return keyshape;
                }

                const listContainer = group.addGroup({});
                //list遮罩
                listContainer.setClip({
                    type: "rect",
                    attrs: {
                        x: -8,
                        y: titleHeight,
                        width: width + 16,
                        height: expandY - titleHeight,
                    },
                });
                //list背景
                listContainer.addShape({
                    type: "rect",
                    attrs: {
                        x: 1,
                        y: titleHeight,
                        width: width - 2,
                        height: expandY - titleHeight,
                        fill: "#fff",
                    },
                    draggable: true,
                });

                // if (list.length > itemCount) {
                //     const barStyle = {
                //         width: 4,
                //         padding: 0,
                //         boxStyle: {
                //             stroke: "#00000022",
                //         },
                //         innerStyle: {
                //             fill: "#00000022",
                //         },
                //     };
                //
                //     listContainer.addShape("rect", {
                //         attrs: {
                //             x: width - barStyle.padding - barStyle.width,
                //             y: titleHeight,
                //             width: barStyle.width,
                //             height: height - titleHeight,
                //             ...barStyle.boxStyle,
                //         },
                //     });
                //
                //     const indexHeight =
                //         afterList.length > itemCount ?
                //             (afterList.length / list.length) * height :
                //             10;
                //
                //     listContainer.addShape("rect", {
                //         attrs: {
                //             y: titleHeight +
                //                 barStyle.padding +
                //                 (startIndex / list.length) * (height - titleHeight),
                //             x: width - barStyle.padding - barStyle.width,
                //             width: barStyle.width,
                //             height: Math.min(height, indexHeight),
                //             ...barStyle.innerStyle,
                //         },
                //     });
                // }
                if (afterList) {
                    afterList.forEach((e, i) => {
                        const isSelected =
                            Math.floor(startIndex) + i === Number(selectedIndex);
                        let {
                            key = "", type
                        } = e;
                        if (type) {
                            key += " - " + type;
                        }
                        const label = key.length > 26 ? key.slice(0, 24) + "..." : key;

                        listContainer.addShape("rect", {
                            attrs: {
                                x: 1,
                                y: i * itemHeight - itemHeight / 2 + offsetY,
                                width: width - 4,
                                height: itemHeight,
                                radius: 2,
                                lineWidth: 1,
                                cursor: "pointer",
                            },
                            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                            name: `item-${Math.floor(startIndex) + i}-content`,
                            draggable: true,
                        });

                        if (!cfg.hideDot) {
                            listContainer.addShape("circle", {
                                attrs: {
                                    x: 0,
                                    y: i * itemHeight + offsetY,
                                    r: 3,
                                    stroke: boxStyle.stroke,
                                    fill: "white",
                                    radius: 2,
                                    lineWidth: 1,
                                    cursor: "pointer",
                                },
                            });
                            listContainer.addShape("circle", {
                                attrs: {
                                    x: width,
                                    y: i * itemHeight + offsetY,
                                    r: 3,
                                    stroke: boxStyle.stroke,
                                    fill: "white",
                                    radius: 2,
                                    lineWidth: 1,
                                    cursor: "pointer",
                                },
                            });
                        }

                        listContainer.addShape("text", {
                            attrs: {
                                x: 12,
                                y: i * itemHeight + offsetY + 6,
                                text: label,
                                fontSize: 12,
                                fill: "#000",
                                fontFamily: "Avenir,-apple-system,BlinkMacSystemFont,Segoe UI,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol",
                                full: e,
                                fontWeight: isSelected ? 500 : 100,
                                cursor: "pointer",
                            },
                            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type
                            name: `item-${Math.floor(startIndex) + i}`,
                        });
                    });
                }


                return keyshape;
            },
            getAnchorPoints() {
                return [
                    [0, 0],
                    [1, 0],
                ];
            },
        });

        const dataTransform = (data) => {
            // const nodes = data.nodes;
            // const edges = data.edges;
            // return {
            //     nodes,
            //     edges,
            // };
            return {
                nodes: data.nodes,
                edges: data.edges,
                combos: data.combos,
            }
        }

        const container = document.getElementById('container');

        const width = container.scrollWidth;
        const height = (container.scrollHeight || 500) - 20;
        const graph = new G6.Graph({
            container: 'container',
            width,
            height,
            defaultNode: {
                size: [300, 200],
                type: 'dice-er-box',
                color: '#5B8FF9',
                style: {
                    fill: '#9EC9FF',
                    lineWidth: 5,
                },
                labelCfg: {
                    style: {
                        fill: 'black',
                        fontSize: 20,
                    },
                },
            },
            defaultEdge: {
                type: 'dice-er-edge',
                style: {
                    stroke: '#e2e2e2',
                    lineWidth: 5,
                    endArrow: true,
                },
            },
            defaultCombo: {
                type: 'rect',
                /* The minimum size of the combo. combo 最小大小 */
                size: [50, 50],
                /* style for the keyShape */
                // style: {
                //   lineWidth: 1,
                // },
                labelCfg: {
                    /* label's offset to the keyShape */
                    // refY: 10,
                    /* label's position, options: center, top, bottom, left, right */
                    position: 'top',
                    /* label's style */
                    // style: {
                    //   fontSize: 18,
                    // },
                },
            },
            /* styles for different states, there are built-in styles for states: active, inactive, selected, highlight, disable */
            /* you can extend it or override it as you want */
            // comboStateStyles: {
            //   active: {
            //     fill: '#f00',
            //     opacity: 0.5
            //   },
            // },
            modes: {
                default: ['dice-er-scroll', 'drag-node', 'drag-canvas', 'drag-combo'],
            },
            layout: {
                type: 'dagre',
                rankdir: 'LR',
                align: 'UL',
                controlPoints: true,
                nodesepFunc: () => 0.2,
                ranksepFunc: () => 0.5,
            },
            animate: true,
            fitView: true
        })

        graph.data(dataTransform(rawData));

        graph.render();

        graph.on('combo:mouseenter', (evt) => {
            const {item} = evt;
            graph.setItemState(item, 'active', true);
        });

        graph.on('combo:mouseleave', (evt) => {
            const {item} = evt;
            graph.setItemState(item, 'active', false);
        });
        graph.on('combo:click', (evt) => {
            const {item} = evt;
            graph.setItemState(item, 'selected', true);
        });
        graph.on('canvas:click', (evt) => {
            graph.getCombos().forEach((combo) => {
                graph.clearItemStates(combo);
            });
        });
    }

    let mock = false
    let mockData = {
        "nodes": [{
            "id": "uml.Base",
            "label": "abstract uml.Base",
            "attrs": [{
                "key": "NodeB",
                "type": "*uml.NodeB wire:\"\"",
                "relation": [{"key": "", "nodeId": "*uml.NodeB"}]
            }]
        }, {
            "id": "*uml.NodeC",
            "label": "class *uml.NodeC",
            "relation": [{"key": "", "nodeId": "uml.I"}, {"key": "", "nodeId": "uml.L"}],
            "attrs": [{
                "key": "Base",
                "type": "uml.Base ",
                "relation": [{"key": "", "nodeId": "uml.Base"}]
            }, {"key": "NodeC", "type": "*uml.NodeC wire:\"\"", "relation": [{"key": "", "nodeId": "*uml.NodeC"}]}]
        }, {
            "id": "*uml.Config",
            "label": "struct *uml.Config",
            "attrs": [{"key": "Configuration.Prefix", "type": "config "}, {
                "key": "Val1",
                "type": "int "
            }, {"key": "Val2", "type": "string "}]
        }, {"id": "uml.I", "label": "interface uml.I", "attrs": [{"key": "Do", "type": "func() "}]}, {
            "id": "uml.L",
            "label": "interface uml.L",
            "attrs": [{"key": "LDo", "type": "func() string "}]
        }, {
            "id": "*uml.NodeA",
            "label": "class *uml.NodeA",
            "attrs": [{
                "key": "Cfg",
                "type": "*uml.Config ",
                "relation": [{"key": "", "nodeId": "*uml.Config"}]
            }, {
                "key": "NodeOne",
                "type": "uml.I wire:\"\"",
                "relation": [{"key": "", "nodeId": "uml.I"}]
            }, {"key": "NodeList", "type": "[]uml.L wire:\"\"", "relation": [{"key": "", "nodeId": "uml.L"}]}]
        }, {
            "id": "*uml.NodeB",
            "label": "class *uml.NodeB",
            "attrs": [{
                "key": "NodeA",
                "type": "*uml.NodeA wire:\"\"",
                "relation": [{"key": "", "nodeId": "*uml.NodeA"}]
            }]
        }],
        "edges": [{
            "source": "uml.Base",
            "target": "*uml.NodeB",
            "sourceKey": "NodeB",
            "targetKey": ""
        }, {
            "source": "*uml.NodeC",
            "target": "uml.Base",
            "sourceKey": "Base",
            "targetKey": ""
        }, {
            "source": "*uml.NodeC",
            "target": "*uml.NodeC",
            "sourceKey": "NodeC",
            "targetKey": ""
        }, {"source": "*uml.NodeC", "target": "uml.I", "targetKey": ""}, {
            "source": "*uml.NodeC",
            "target": "uml.L",
            "targetKey": ""
        }, {
            "source": "*uml.NodeA",
            "target": "*uml.Config",
            "sourceKey": "Cfg",
            "targetKey": ""
        }, {
            "source": "*uml.NodeA",
            "target": "uml.I",
            "sourceKey": "NodeOne",
            "targetKey": ""
        }, {
            "source": "*uml.NodeA",
            "target": "uml.L",
            "sourceKey": "NodeList",
            "targetKey": ""
        }, {"source": "*uml.NodeB", "target": "*uml.NodeA", "sourceKey": "NodeA", "targetKey": ""}]
    }

    if (mock) {
        render(mockData)
    } else {
        axios.post('http://localhost:8888/schema').then(function (response) {
            render(response.data)
        })
    }

    if (typeof window !== 'undefined')
        window.onresize = () => {
            if (!graph || graph.get('destroyed')) return;
            if (!container || !container.scrollWidth || !container.scrollHeight) return;
            graph.changeSize(container.scrollWidth, container.scrollHeight);
        };
</script>
</body>
</html>